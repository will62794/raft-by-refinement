
# Consensus Log Refinement

This directory models a hierarachy of consensus log protocols, starting from a very abstract spec `Log`, and incrementally refining it down to more detailed specifications. 

`Log.tla`

This attempts to be the most abstract spec of an operation log possible. Since it so abstract, it is essentially trivial. We model an operation log as a set of "chosen" values, where each chosen value is recorded as a `<<index, value>>` tuple. We could arguably model this more naturally in TLA+ as a sequence of values i.e. `<<v1,v2,v3>>`, but that wouldn't allow us to represent cases where we wrote down two different values at the same index, which should be one of the fundamental safety properties of an operation log. This safety property is encoded as `ChosenSafety` in `Log.tla`. We expect that all operation logs that refine `Log` should satisfy this safety property. When we are at this high level of abstraction, we guarantee this safety property by construction in `Log.tla`, since we only add a new chosen value `<<i,v>>` to the set of chosen entries if we haven't yet chosen a value at index `i`. For lower-level specs, though, the expectation is that satisfaction of this property may not be so trivial.

`DistLog.tla`

This spec is a very abstract version of a distributed operation log and is a refinement of `Log.tla`. It is  "distributed" in the sense that we model multiple servers, who can each append or delete entries from their own operation log. Beyond that, though, it is a very coarse abstraction of a real distributed system i.e. no message passing and we assume many of the most important actions can read parts of the global state atomically. To refine `Log.tla`, we simply need to define a mapping from each state of `DistLog` to the state of `Log`, which only consists of a single variable: `chosen`. We define the `Log!chosen` variable as a function of all node logs in `DistLog`. We define a very simple rule for whether a log value is chosen at index `i`: if all servers contain the same value at index `i`. In a real system, this likely wouldn't satisfy any kind of desired fault tolerance properties, but the intention is to define the simplest possible spec at each abstraction layer, and then work down from there, regardless (to some extent), of how you would implement a system that provides the same guarantees. Hopefully, when we get down to a low enough level of abstraction, then it would become clearer how to actually implement a distributed system that implements the extremely abstract specs `Log`/`DistLog`.